#### 序列
> 比如，每一计算机程序都可以看作一个序 列，它由一系列依次排列的指令组成，正是指令之间的次序决定了程序的具体功能。
> 因此，所谓序 列，就是一组对象之间的后继与前驱关系。在实际问题中，序列可以用来实现很多种数据结构，
> 因此被认为是数据结构设计的基础。
> 向量(Vector)和列表(List)。它们都由一组按线性次序排列的 元素组成，并支持若干个访问、插入和删除元素的方法

> chapt02 中介绍的几种数据结构
> 队列以及双端队列，都可以看作带有附加限制的序列
> :插入、删除 和访问操作只限于首元素的，就是栈;
> 删除和访问操作只限于首元素、插入操作只限于末元素的， 就是队列;
> 前、后端都支持插入、删除和访问操作的，就是双端队列。
>
> 作为更一般性的结构，序列 依然保持了这些结构的一条重要性质:其中各元素的逻辑次序与其数值无关，
> 只取决于在序列结构 生命期内所执行过的具体ADT操作。
>
> 对数组结构进行抽象与扩展之后，就可以得到向量结构，因此向量也称作数组列表(Array list)
> 向量提供一些访问方法，使得我们可以通过下标直接访问序列中的元素，也可以将指定下标处的元 素删除，或将新元素插入至指定下标
> 
> 支持通过秩（索引）直接访问其中元素的序列，称作向量(Vector)或数组列表(Array list)
>
固定大小的向量
> 数组容量N固定。一方面，在向量规模很小时， 预留这么多的空间实属浪费;反过来，
> 当向量规模超过N时，即使系统有足够的空间资源，也会因 意外错而崩溃。幸好，有一个简易的方法可以克服这一缺陷
> 动态地扩充数组的容量。当然，Java 语言本身并不支持这一 功能，与多数程序语言一样，Java 中数组的容量都是固定的。
> 我们的策略是，一旦数组空间溢出(即 n≥N)，insertAtRank()方法就会做如下处理:
> 与简单的数组实现相比，基于可扩充数组的实现可以更高效地利用存储空间。另外，只要系统 还有可利用的空间，
> 向量的最大规模将不再受限于数组的容量。然而，我们也需要为此付出代价⎯⎯ 每次扩容时，需要花费额外的时间以将原数组的内容复制到新数组中。
> 准确地说，为了将数组的容 量由 N 扩至 2N，需要花费 O(N)的时间。
> 每经过一次扩充，数组的容量都会加倍，此后，至少要再经过 N 次插入操作，才有可能需要再次扩 容。
> 也就是说，随着向量规模的增加，需要进行扩容的概率会急剧下降
>
> 序列ADT将同时支持向量ADT与列表ADT中的所有 方法，此外，还支持以下两个方法⎯⎯正是借助这两个方法，
> 我们才得以将秩和位置的概念联系起来
>
> 与链表相对称地，我们也可以利用数组来实现序列
> 将序列 S 中的各个元素分别存放到数组 A[]对应的单元中。具体地，每一位置对象除了设有一个引用指向数组 A[]，同时还保存一个下标 i。 
> 这就使得 getElem(p)方法可以直接返回 A[i]。这种实现也有不足:A[]中的单元无法直接得到各自对 应的位置。比如，在执行 
> insertFirst()操作时，我们将无法通知 S 中相关的那些位置，以便它们将各 自的秩加一
> (你应该还记得，序列中的位置总是相对于其前后邻居而言的，而不是它们的秩)。因此， 为了利用数组来实现一个通用的序列结构，
> 我们只能另想办法。书中有方案介绍，并没有实现
>
> 迭代器
> 是软件设计的一种模式，它是对“逐一访问所有元素”这类操 作的抽象。
> 迭代器本身也是一个序列S，在任何时候，迭代器中都有唯一的当前元素。迭代器还必须提供 某种机制，
> 使得我们可以不断转向S中的下一元素，并将其置为新的当前元素。
> 迭代器 ADT 始终维护了一个“当前”元素。只要迭代器 非空，那么对 getNext()方法的首次调用就会给出最初始的当前元素。
> 迭代器提供了一种统一的机制，无论对象之间的具体组织形式如何，它都可以从一组对象中为 我们逐一列举出每个元素。
> 对于向量、列表或序列之类具有线性次序的结构，迭代器还必须能够按 照这一次序给出其中的元素。