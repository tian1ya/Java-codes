### 什么是函数式编程
> 使用函数编程，是一种聚焦在函数上的编程方式
> scala 并不是纯粹的函数式编程语言，同时还承认 非纯粹函数和纯函数
> scala 程序猿是被鼓励使用纯函数编程的，副作用异常是没有被禁止的，事实
> 上副作用有时候用起来也是比较方便的，
> 过渡的使用副作用并不是一种好的方式，在scala 中 使用非纯函数编程
> 可能是方便的
> 函数式编程（FP）思想
>   面对对象（OOP）可以理解为是对数据的抽象，比如把一个人抽象成一个Object，关注的是数据。 
>   函数式编程是一种过程抽象的思维，就是对当前的动作去进行抽象，关注的是动作。
>   面对对象（OOP）可以理解为是对数据的抽象，比如把一个人抽象成一个Object，关注的是数据。 
>   函数式编程是一种过程抽象的思维，就是对当前的动作去进行抽象，关注的是动作。
>
> 经过了一段时间的泛函编程讨论，始终没能实实在在的明确到底泛函编程有什么区别和特点；我是指在现实编程的情况下所谓的泛函编程到底如何特别。我们已经习惯了传统的行令式编程（imperative programming），
> 总是先入为主的认为软件编程就是一行接着一行的更改某些变量状态指令：明刀明枪，字里行间目的和方式都很明确。我们就以一步步更改程序状态的方式，一行一行的拼凑指令：这就是典型的行令式编程了。
 
> 泛函编程，顾名思义，就是用一个个函数来编程。讲的再深入点就是通过函数组合来更改程序状态。什么意思？为什么？

> 严格来讲，在泛函编程中是没有在某个地方申明一个变量，然后在一些函数里更新这个变量这种方式的。与申明变量相对应的是泛函编程会把所谓变量嵌入在一个结构里，如：F[A]。F是某种高阶类型，A就是那个变量。如果我们需要去更改这个变量A就必须设计一套专门的函数来做这件事了。
> 从某些方面这也解释了何谓泛函编程。我用粗俗的语言来描述这两种编程模式的区别：行令编程就像在床面上打扑克，而泛函编程就好比在被窝里打牌。两种操作一样都是打牌，只是打牌的环境不同。实际上泛函编程的这种在套子内部更新变量的方式恰恰是我们选择泛函模式的考虑重点：
> 它可以使程序运行更安全稳定、能轻松解决很多行令编程模式中存在的难题，这些优点将会在将来的应用中逐渐显现出来。
> 既然变量封装在了套子里面，那么自然需要设计一些在套子里更新变量的函数了：
> 我们的目的是用某些函数把F[A]变成F[B]：A 变成了 B，但任然封装在 F[] 里：
>[以上一段是来源于这篇博客](https://www.cnblogs.com/tiger-xc/p/4546702.html)
---
### 第一章
#### 什么是函数式编程
只用纯函数来构造程序，也就是意味着函数没有**副作用**，
函数式编程限制的是如何写程序，而不是表达什么样的程序，
函数式编程的及其有益的，因为使用纯函数编程更加模块化，而模块化那么久意味着
更好的被测试、复用、并行。泛化等的好处。

对于函数式编程的实现，应该有一个纯的内核和一层很薄的外围来处理副作用。

纯函数：一个函数的输出除了根据输出参数给出运算结果之外没有其他的影响，这样就说是没有副作用的

引用透明：在程序P 中，任何引用表达式f(x) 的地方，都可以被 f(x) 的输出结果
   替换，而且不影响程序 P 的运行(没有额外的作用，给定输入，那么就给定了输出)，那么说 P 对 f(x) 的的引用是引用透明的，这里
   也看出满足引用透明那么 f(x) 表达式就是一个纯函数
  
代替模型：引用透明要求函数不论进行何种操作都可以使用它的返回值替换
    这种替换是的推导程序的求值边的简单，称之为代替模型
---

#### 第二章
尾递归函数：

高阶函数：可以接收一个函数作为参数或者将函数作为它的返回值输出

多态：泛型函数，如在函数签名中参数类型为 p:(Int, Int) => Boolean
    那么传入的参数 p 输入必须是Int， Int 的2个参数，而输出必须是
    Boolean 类型的

scala 中一个函数的返回值等于函数右手边的值，所以不需要使用return 关键字
    右手边往往是使用花括号包含的多行代码块，代码块的值就是它最后一个表达式的值

尾递归： 尾调用在一个递归调用之后就不会做其他事情，只是返回这个调用的结果

尾递归优化(消除尾递归)：尾递归的递归方法编译器优化成类似 while 的循环, 这样不会每次迭代都会进行栈的操作
    默认编译器不会告诉你尾递归是否消除 
    
匿名函数：没有函数名字如有一个函数 
```scala
        def a(p:(Int, Int) => Boolean) = {...}
        
        a((a,b) => a + b)
```
    那么函数 a,b) => a + b 就是匿名函数
    
函数也是值：在自定一个函数字面量的时候，实际上定义了一个包含 apply 方法的 scala 对象
    scala 对这个方法名有着特别的规则，一个由 apply 方法的对象可以把
    它当成方法一样调用，这也就意味着在创建一对象的时候，如果这个对象
    实现了 apply 方法，那么创建这个方法可以不使用 new 关键字
    在伴生对象中定义一个 applyly 以便构造这个数据类型的实例，是一种惯例
    
---
#### 第三章： 函数式数据结构
    因为纯函数是一定不能修改原始的数据或者产生副作用，所以函数式子数据结构
    被定义为不可变的。注意这里并不意味着对数据做额外的赋值
    
伴生对象：和数据类型同名的一个单例(java 的静态方法/变量)

List[+A]: +A 表示协变, 型变是正向的，如果 A 是 B 的子类型，那么 List[A] 就是 List[B] 的子类型
List[-A]: -A 表示逆变，型变是逆向的，如果 A 是 B 的子类型，那么 List[B] 就是 List[A] 的子类型。

trait: 可以包含具体方法(可选)的抽象接口

sealed：
    其修饰的trait，class只能在当前文件里面被继承；
    在检查模式匹配的时候，用sealed修饰目的是让scala知道这些case的所有情况，scala就能够在编译的时候进行检查，
    看你写的代码是否有没有漏掉什么没case到，减少编程的错误。
    
可变参数： 参数列表中，可变参数会被scala 编译器绑定到 Seq[A] 的类型上

在List 代码中我们的Cons 方法在 scala 的标志库中是 ::, 使用右结合
    1::2::3 == Cons(1, Cons(2, Cons(3, Nil)))
    在使用模式匹配的时候也应该是 h::t
    
### 第四章：不是用异常来处理错误
在之前提到函数式中跑出异常属于副作用，那么如果不跑出异常，那么使用什么替代呢？

函数式编程中如何使用普通的值表现失败和异常：通过高阶函数抽象出错误处理和恢复的常用模式

在函数式编程中以返回值的方式返回错误更安全，且符合引用透明

一般情况跑出异常的问题：
1. 破坏引用透明，并引入上下文依赖(坊间一个习惯是建议异常应该用户错误处理而不是控制流)
2. 异常不是类型安全的

Java 异常检测导致了调用者对签名模板的修改，而且他们是不适合用于高阶函数的，因为高阶函数不可能感知由
它的参数引起的特定异常

Scala 的异常处理也是早已经存在的理念，替代跑出异常，而是返回一个值来表示异常情况的发生(Java 的Optional 类型)

Option 数据类型明确告诉该函数的返回并不总是有答案，但是它还是会返回
    该数据类型贯穿整个 scala 标准库
    
def orElse[B >: A](ob: => Option[B]): Option[B]
    表示类型 表示B 必须等于A 类型或者A 类型的父类型
    
Try函数: 是一个通用目的的函数，用于将一个基于异常的API 转换为一个面向
    Option 的API
    
提升： 任何一个已经存在的普通的函数都可以转换为一个在Option 值的上下文中进行操作
    的函数
    def lift[A,b](f: A => B): Option[A] => Option[B]
    
这一章的核心是可以用普通的值类表现失败和异常，将错误处理和恢复的通用
    模式抽象出来用函数实现，Option 不是用于这种目的的唯一数据类型
    它过于简单，Option 不会告诉我们在一次条件下发送了什么错误
    只是给一个None，表示没有可用的值，但有事我们想要知道更多
    这种情况下使用: Either
    
Either：子类 Left 和 Right 分别表示错误和正确的返回结果 
 
标准库中的Option 和 Either 是有一些区别的

#### 第五章： 严格和非严格求职
    在之前实现的 List 中，当对List 做 如map。filter map 操作
    那么会产生2个中间结果，然后在计算到下一个的时候，上一个的中间
    结果就丢弃的。
    
    那么是否可以在写这些map filter map 等操作的时候并不先计算，当定义好这个过程
    之后，然后将这一系列的操作全部都融合在一起，然后触发操作，这样就不会有中间结果了
    
    采用非严格函数就可以完成这样的操作
    
    在scala 中除非明确声明，否则所有的求职都是严格的
    
    非严格求值，理解起来就是将一个数写成，表达式，运行这个表达式获得表达式的返回值，才是得到这个值
    
#### 第10章：Monoid
    是一类代数操作的描述，满足
        1. 一个抽象类型 A
        2. (结合律:associative laws)一个可结合的二元操作，它接收2个参数然后返回相同类型的值，对于任何 x: A, Y: A, z: A
           这两个操作的等价的： op(op(x,y), z) == op(x, op(y,z))
        3. (同一律)一个值， zero: A， 它是一个单位元，对于任何x: A 来说， zero 和它的操作都是等价于 x 本身
            ： op(z, zero) == x 或者 op(zero, x) == x
            
    使用 Scala 表达就是 Monoid
    
    所以除了满足 monoid 的法则，什么是Monoid 呢？
        简单的就是它是一个类型，一些操作和一些法则，一个 monoid 是一个代数结构，没有别的
        
    使用monoid 折叠列表， monoid 和列表有紧密的联系，仔细观察其签名
    
    def foldRight[B](z: B)(f:(A,B) => B)
    def foldLeft[B](z: B)(f: (B,A) => B)
    
    加入当类型A 和 B 一样的时候
    def foldRight[B](z: B)(f:(B,B) => B)
    def foldLeft[B](z: B)(f: (B,B) => B)
    
    结合律和并行化
        右折叠：op(a, op(b, op(c,z)))
        左折叠：op(op(op(z, a), b), c)
        平衡折叠：op(op(a,b), op(c,d))
    也就是晚上上面的动作得到的结果是等同的
        
    类型构造器：
         F[_] 是高阶类型（higher-kinder type），它接受一个类型参数
         List[T] => List[List[T]] => List[F[_]] 二阶泛型(F[_] List[T]) 的泛型
         
    实际上Monoid就是List[A] => A的抽象模型
    所有数据类型的Monoid实例都共同拥有一套Monoid特有的操作及遵循一套Monoid行为定律。这样我们可以把Monoid视为一个抽象数据模型，
    在泛函算法中使用特殊的Monoid实例就可以达到预期的效果而不需要修改算法
        
#### 第11章：Monad
    Monad: 
        Monad是一种定义将函数(函子)组合起来的结构方式，且这些组合的方法都是符合结合律的。
    
    那么函子是什么呢 ？ 
        /Users/xuxliu/Ifoods/Java/leetcode/src/thread.book.main/scala/fp/chapt11
    有一些注释，出了知道满足那几个定理，以及类型公共方法算子的抽象组合，也没大明白什么是Monad
    
```scala
trait Functor[F[_]] {
  def map[A, B](fa: F[A])(f: A => B): F[B]
}
```
    Functor 可以和一阶泛型中的 function 对应起来理解，只不过Functor 是在二阶上的映射
     是套在一个圈子里面的(这里的圈子就是说二阶泛型F)
     一样的是他也是有一个map 函数的，如上面的 trait 定义的，map 完成 F[A] => F[B] 的映射，在一个封闭的高阶类型上下文中完成操作
    
    抽象出这些感念的意图就是，针对这些数据类型的特性，设计最基本的操作函数或者组件，而使用 unit 和 flatMap
    可以实现各种各样的操作，包括map(unit + flatMap 更加的抽象,也就是更加的概括)
    Monad 就是使用 unit + flatMap 最为最基本的组件
```scala
trait Monad[F[_]] extends Functor[F] {
  def unit[A](a: => A): F[A]
  def flatMap[A, B](ma: F[A])(f: A => F[B]): F[B]
}
```
    我们似乎可以这么说最为 map 为原语(最基本操作)的trait 就是一个 functor
    而以 unit + flatMap 为原语的 trait 就是一个 Monad
    
    也 提到过 functor 是在一个二阶环境中进行的操作，也就是 F[A] => F[B] 都是在F 这个上下文中进行的映射
    而Monad 就比较强大的多了，因为flatMap 的存在可以在不同的上下文中进行映射，如flatMap 中的函数 f:A=>F[B]
    
    但是 flatMap + unit 并不是Monad 唯一的最基本的组件函数，还有 compose+unit及join+map+unit这两组Monad最基本组件函数，因为我们可以用这些组件相互实现：
    所以，我们可以通过直接对数据类型实现join+map+unit或compose+unit来产生Monad实例。
    
    Monad 是一个超级概括的数据类型，必须兼容各种设计模式，无法专注对一些特殊的操作模式，
    在泛函编程模式中最具有特点的就是在一个封闭的结构内运行函数，比较明显的就是map2这个函数了
```scala
def map2[A,B,C](ma: M[A], mb: M[B])(f: (A,B) => C): M[C]
```
    map2在2个封闭的高阶类型结构中的元素通过运行f 函数结合起来，完成操作之后产生的结果仍然保持结构的完整性，这种典型的泛函编程函数
    施用模式
    
    于是将这种在2个高阶类型结构中通过施用f函数，并产生的结果仍然保持结构的完整性这种模式独立出来称为 Applicative
    
### 第12章：可应用函子/可遍历函子
    当然 map2 + unit 并不是 Monad 的原语，因为他们两个无法实现 flatMao、join 等
    但是 flatMap 可以来实现 map2 以及后面的 apply ，所以 Monad 就是 Applicative
    
    查看三者 map、flatMap、map2 三者的函数签名
```scala
def map[A,B]      (ma: M[A])(f: A => B)              : M[B]
def map2[A,B,C]   (ma: M[A], mb: M[B])(f: (A,B) => C): M[C]
def flatMap[A,B]  (ma: M[A])(f: A => M[B])           : M[B]
```
    其中 map 和 flatMap 都是正宗的在高阶数据类型结构内的函数施用，但是 flatMap 的函数是 A => M[B]
    会破坏结果的结构，
    
    而我们定义 Applicative 专注的是函数的施用
```scala
def apply[A,B](fab: F[A => B])(fa: F[A]): F[B]
```
    上面的函数签名可以发现，apply 施用函数是通过一个Monaic 穿进去的，这就是的 apply 比map 更加强大
    
    244 行提到 flatMap 会破坏结果，那么看哈三者的实现，就知道怎么回事了
```scala
def Map2[A,B,C](ma: Option[A], mb: Option[B])(f: (A,B) => C): Option[C] = {
      (ma,mb) match {
          case (Some(a),Some(b)) => Some(f(a,b))
          case _ => None
      }
  }
def apply[A,B](ma: Option[A])(f: Option[A => B]): Option[B] = {
      (ma,f) match {
          case (Some(a),Some(f)) => Some(f(a))
          case _ => None
      }
}
def flatMap[A,B](ma: Option[A])(f: A => Option[B]): Option[B] = {
      ma match {
          case Some(a) => f(a)
          case _ => None
      }
}
```
    apply 和 Map2 返回的还均是在一个 高阶函数(Some)中, 但是 flatMap 且不一定，其取决于 f(a) 的定义，所以会破坏
    
    applicative 比较与 Monad 会弱一点，这也就给了它更多的灵活性
    
    