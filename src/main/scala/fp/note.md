### 什么是函数式编程
> 使用函数编程，是一种聚焦在函数上的编程方式
> scala 并不是纯粹的函数式编程语言，同时还承认 非纯粹函数和纯函数
> scala 程序猿是被鼓励使用纯函数编程的，副作用异常是没有被禁止的，事实
> 上副作用有时候用起来也是比较方便的，
> 过渡的使用副作用并不是一种好的方式，在scala 中 使用非纯函数编程
> 可能是方便的
> 函数式编程（FP）思想
>   面对对象（OOP）可以理解为是对数据的抽象，比如把一个人抽象成一个Object，关注的是数据。 
>   函数式编程是一种过程抽象的思维，就是对当前的动作去进行抽象，关注的是动作。
>   面对对象（OOP）可以理解为是对数据的抽象，比如把一个人抽象成一个Object，关注的是数据。 
>   函数式编程是一种过程抽象的思维，就是对当前的动作去进行抽象，关注的是动作。
---
### 第一章
#### 什么是函数式编程
只用纯函数来构造程序，也就是意味着函数没有**副作用**，
函数式编程限制的是如何写程序，而不是表达什么样的程序，
函数式编程的及其有益的，因为使用纯函数编程更加模块化，而模块化那么久意味着
更好的被测试、复用、并行。泛化等的好处。

对于函数式编程的实现，应该有一个纯的内核和一层很薄的外围来处理副作用。

纯函数：一个函数的输出除了根据输出参数给出运算结果之外没有其他的影响，这样就说是没有副作用的

引用透明：在程序P 中，任何引用表达式f(x) 的地方，都可以被 f(x) 的输出结果
   替换，而且不影响程序 P 的运行(没有额外的作用，给定输入，那么就给定了输出)，那么说 P 对 f(x) 的的引用是引用透明的，这里
   也看出满足引用透明那么 f(x) 表达式就是一个纯函数
  
代替模型：引用透明要求函数不论进行何种操作都可以使用它的返回值替换
    这种替换是的推导程序的求值边的简单，称之为代替模型
---

#### 第二章
尾递归函数：

高阶函数：可以接收一个函数作为参数或者将函数作为它的返回值输出

多态：泛型函数，如在函数签名中参数类型为 p:(Int, Int) => Boolean
    那么传入的参数 p 输入必须是Int， Int 的2个参数，而输出必须是
    Boolean 类型的

scala 中一个函数的返回值等于函数右手边的值，所以不需要使用return 关键字
    右手边往往是使用花括号包含的多行代码块，代码块的值就是它最后一个表达式的值

尾递归： 尾调用在一个递归调用之后就不会做其他事情，只是返回这个调用的结果

尾递归优化(消除尾递归)：尾递归的递归方法编译器优化成类似 while 的循环, 这样不会每次迭代都会进行栈的操作
    默认编译器不会告诉你尾递归是否消除 
    
匿名函数：没有函数名字如有一个函数 
```scala
        def a(p:(Int, Int) => Boolean) = {...}
        
        a((a,b) => a + b)
```
    那么函数 a,b) => a + b 就是匿名函数
    
函数也是值：在自定一个函数字面量的时候，实际上定义了一个包含 apply 方法的 scala 对象
    scala 对这个方法名有着特别的规则，一个由 apply 方法的对象可以把
    它当成方法一样调用，这也就意味着在创建一对象的时候，如果这个对象
    实现了 apply 方法，那么创建这个方法可以不使用 new 关键字
    在伴生对象中定义一个 applyly 以便构造这个数据类型的实例，是一种惯例
    
---
#### 第三章： 函数式数据结构
    因为纯函数是一定不能修改原始的数据或者产生副作用，所以函数式子数据结构
    被定义为不可变的。注意这里并不意味着对数据做额外的赋值
    
伴生对象：和数据类型同名的一个单例(java 的静态方法/变量)

List[+A]: +A 表示协变, 型变是正向的，如果 A 是 B 的子类型，那么 List[A] 就是 List[B] 的子类型
List[-A]: -A 表示逆变，型变是逆向的，如果 A 是 B 的子类型，那么 List[B] 就是 List[A] 的子类型。

trait: 可以包含具体方法(可选)的抽象接口

sealed：
    其修饰的trait，class只能在当前文件里面被继承；
    在检查模式匹配的时候，用sealed修饰目的是让scala知道这些case的所有情况，scala就能够在编译的时候进行检查，
    看你写的代码是否有没有漏掉什么没case到，减少编程的错误。
    
可变参数： 参数列表中，可变参数会被scala 编译器绑定到 Seq[A] 的类型上

在List 代码中我们的Cons 方法在 scala 的标志库中是 ::, 使用右结合
    1::2::3 == Cons(1, Cons(2, Cons(3, Nil)))
    在使用模式匹配的时候也应该是 h::t
    
### 第四章：不是用异常来处理错误
在之前提到函数式中跑出异常属于副作用，那么如果不跑出异常，那么使用什么替代呢？

函数式编程中如何使用普通的值表现失败和异常：通过高阶函数抽象出错误处理和恢复的常用模式

在函数式编程中以返回值的方式返回错误更安全，且符合引用透明

一般情况跑出异常的问题：
1. 破坏引用透明，并引入上下文依赖(坊间一个习惯是建议异常应该用户错误处理而不是控制流)
2. 异常不是类型安全的

Java 异常检测导致了调用者对签名模板的修改，而且他们是不适合用于高阶函数的，因为高阶函数不可能感知由
它的参数引起的特定异常

Scala 的异常处理也是早已经存在的理念，替代跑出异常，而是返回一个值来表示异常情况的发生(Java 的Optional 类型)

Option 数据类型明确告诉该函数的返回并不总是有答案，但是它还是会返回
    该数据类型贯穿整个 scala 标准库
    
def orElse[B >: A](ob: => Option[B]): Option[B]
    表示类型 表示B 必须等于A 类型或者A 类型的父类型
    
Try函数: 是一个通用目的的函数，用于将一个基于异常的API 转换为一个面向
    Option 的API
    
提升： 任何一个已经存在的普通的函数都可以转换为一个在Option 值的上下文中进行操作
    的函数
    def lift[A,b](f: A => B): Option[A] => Option[B]
    
这一章的核心是可以用普通的值类表现失败和异常，将错误处理和恢复的通用
    模式抽象出来用函数实现，Option 不是用于这种目的的唯一数据类型
    它过于简单，Option 不会告诉我们在一次条件下发送了什么错误
    只是给一个None，表示没有可用的值，但有事我们想要知道更多
    这种情况下使用: Either
    
Either：子类 Left 和 Right 分别表示错误和正确的返回结果 
 
标准库中的Option 和 Either 是有一些区别的

#### 第五章： 严格和非严格求职
    在之前实现的 List 中，当对List 做 如map。filter map 操作
    那么会产生2个中间结果，然后在计算到下一个的时候，上一个的中间
    结果就丢弃的。
    
    那么是否可以在写这些map filter map 等操作的时候并不先计算，当定义好这个过程
    之后，然后将这一系列的操作全部都融合在一起，然后触发操作，这样就不会有中间结果了
    
    采用非严格函数就可以完成这样的操作
    
    在scala 中除非明确声明，否则所有的求职都是严格的
    
    非严格求值，理解起来就是将一个数写成，表达式，运行这个表达式获得表达式的返回值，才是得到这个值
    
#### Monoid
    是一类代数操作的描述，满足
        1. 一个类型 A
        2. (结合律:associative laws)一个可结合的二元操作，它接收2个参数然后返回相同类型的值，对于任何 x: A, Y: A, z: A
           这两个操作的等价的： op(op(x,y), z) == op(x, op(y,z))
        3. (同一律)一个值， zero: A， 它是一个单位元，对于任何x: A 来说， zero 和它的操作都是等价于 x 本身
            ： op(z, zero) == x 或者 op(zero, x) == x
            
    使用 Scala 表达就是 Monoid
    
    所以除了满足 monoid 的法则，什么是Monoid 呢？
        简单的就是它是一个类型，一些操作和一些法则，一个 monoid 是一个代数结构，没有别的
        
    使用monoid 折叠列表， monoid 和列表有紧密的联系，仔细观察其签名
    
    def foldRight[B](z: B)(f:(A,B) => B)
    def foldLeft[B](z: B)(f: (B,A) => B)
    
    加入当类型A 和 B 一样的时候
    def foldRight[B](z: B)(f:(B,B) => B)
    def foldLeft[B](z: B)(f: (B,B) => B)
    
    结合律和并行化
        右折叠：op(a, op(b, op(c,z)))
        左折叠：op(op(op(z, a), b), c)
        平衡折叠：op(op(a,b), op(c,d))
        
    类型构造器：
         F[_] 是高阶类型（higher-kinder type），它接受一个类型参数
         List[T] => List[List[T]] => List[F[_]] 二阶泛型(F[_] List[T]) 的泛型
        
#### Monad
    Monad: 
        Monad是一种定义将函数(函子)组合起来的结构方式，且这些组合的方法都是符合结合律的。
    
    那么函子是什么呢 ？ 
        /Users/xuxliu/Ifoods/Java/leetcode/src/main/scala/fp/chapt11
    有一些注释，出了知道满足那几个定理，以及类型公共方法算子的抽象组合，也没大明白什么是Monad
        
    