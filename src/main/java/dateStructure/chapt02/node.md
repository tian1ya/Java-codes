### 数据结构
什么是数据结构：数据结构就是指相互之间存在着一种或者多种关系的元素的集合和该集合中数据元素之间的关系的组成， 就是说数据和数据直接的关系

数据的存储结构： 数据再内存中的如何存储的
    顺序存储：数据元素存储再连续的内存中，如：数组。插入数据代价大，需要将后面的数据全部后移
    列式存储，存储的空间并不是连续的，数据随便放，只需要维护这数据之间的的首位关系，也就是头和尾的连接关系，如 list。插入数据方便
    

数据的逻辑结构：数据和数据之间的关系
    集合结构:
    线性结构:
    树形结构: 一对多的树形结构，一个老爸有多个儿子，文件-文件夹中使用的会最多
    图形结构: 多对多的关系
    

### 算法
什么是算法：解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代码这用系统的方法描述解决问题的简略机制
            就是解决问题的思路，步骤，
            
算法：
    输入，
    输出，
    有穷性：有限的步骤执行结束
    确定性：结果是确定的，而不是随机的
    可行性：可以解决实际问题
    
基本要求
    正确性
    可读性
    健壮性
    时间复杂度
    空间复杂度
    
算法没有最好的，只有最适合的

### 栈
后进先出 LIFO， 对象可以任意插入栈中，但是每次取出来的都是此前插入的最后一个对象

* Java 虚拟机中的栈
> Java 中的每一个程序都被编译为一个二进制的指令序列，这些指令可以在一个特定的计算模型Java 虚拟机上执行， 正是由于可以将Java 源程序
> 编译为JVM可以执行的代码，而不是在某一特定的CPU 上之间执行代码，是的Java 程序可以运行在任何计算机
> Java 方法栈(Java Stack), 用于记录各个方法在被调用过成中的局部变量等重要信息。 
>
> 在Java程序执行期间，JVM 会维护一个栈，其中的元素分别是当前活跃的某个方法实例的描述符号，称为帧(Frame), 如： 若方法N 调用了方法
> M， 则在M 的这个实例的一样的帧中记录了该实例的调用参数以及其中的局部变量还有关于N 的信息，以及在M执行结束时应该分会给N 的东西。
>
> Java 栈中最顶层的帧总是对应于当前正在执行的方法的实例，其余的各帧分别对应于某个被挂起，尚未执行完的方法，居于栈低的那一帧对应于main 
> 方法，其余各帧自定向上安装被调用的次序顺序排列，每当有一个方法被调用，其对应的帧就会被压入栈，一旦当前方法实例运行结束，帧出站，控制权
> 交给新栈顶所对应的方法实例。
>
> JVM 还会通过 Java 栈将参数传递给被调用的方法。具体来说，Java 是按照“值传递” (Call-by-value)的方式传递参数的。也就是说，
> 以参数形式传递给被调用方法的，总是变量或表 达式当前的实际值。
>
> >对于属于基本类型(比如int或float)的变量x，x的当前值就是其算数值。假设方法N调用方法M 时，如果x作为参数传递给M，
> 那么x的当前值就会被复制到M所对应帧中的某个局部变量(参见 图 二.3)。需要指出的是，此后即使方法M修改了该局部变量的数值，
> x在N中的数值也决不会受到影响。
>
> >不过，倘若 x 是指向某对象 o 的一个引用，那么 x 的当前值就是对象 o 的内存地址。因此，如 果将 x 作为参数传递给方法 N，
> 实际上传递的是对象 o 的内存地址。这个地址被复制给 N 的某个局 部变量 y 之后，y 也将和 x 一样地指向对象 o。

* 递归和栈
```java
    public static long factorial(long n) {
        if (n <= 1)
            return 1;
        else
            return n * factorial(n -1);
    }
```
> 借助栈来实现方法调用的优点之一，就是支持程序的递归
> Java允许方法直接或间接地自我调用。鉴于递归程序的简洁性和高效性，现代程序设计语言几乎都 采用了这一模式
> 如果对递归程序的运行进行跟踪，那么每一个方框都分别对应于 Java 方法栈中的某一帧。而 且，在任一时刻，Java 方法栈中的所有帧，自底向上依次对应于从方法 thread.book.main 到当前活跃方法的一 条调用路径。

#### 队列
对象的插入和删除遵循 "先进先出"(First in First Out) 【先到的客户优先接受服务】
* 基于顺序数组实现
> 一种自然的办法就是仿照栈的实现，以 Q[0]作为队首，其它对象顺序往后存放。然而如此一来， 每次首元素出队之后，
> 都需要将后续的所有元素向前顺移一个单元⎯⎯若队长为 n，这项工作需要 O(n)时间，因此效率很低。

* 循环数组
> 为了避免数组的整体移动，可以引入如下两个变量 f 和 r:
> f:始终等于Q的首元素在数组中的下标，即指向下次出队元素的位置
> r:始终等于Q的末元素的下标加一，即指向下次入队元素的位置
> 一开始，f = r = 0，此时队空。每次有对象入队时，将其存放于 Q[r]，然后 r 加一，以指向下一 单元。对称地，
> 每次有对象出队之后，也将 f 加一，指向新的队首元素。这样，对 front()、enqueue() 和 dequeue()方法的每一次调用都只需常数时间。
> 然而，这还不够。细心的读者或许已经注意到，按照上述约定，在队列的生命期内，f 和 r 始终 在单调增加。因此，若队列数组的容量为 
> N，则在经过 N 次入队操作后，r 所指向的单元必然超出 数组的范围;在经过 N 次出队操作后，f 所指向的单元也会出现类似的问题。
  解决上述问题的一种简便方法，就是在每次 f 或 r 加一后，都要以数组的长度做取模运算，以 保证其所指单元的合法性。就其效果而言，
> 这就相当于把数组的头和尾相联，构成一个环状结构。
> 队列中插入还是取出数据都是按照 r 或者 f 俩个index决定的，所以对 f 和 r 取摸之后并不会影响到队列中的数据

> 经利用数组实现了栈与队列, 这种方法简单明了，但是由于数组长度必须固定，在空间效率及适应性方面还存在不足
---

#### 列表
> 按线性次序排列的一组数据节点，每个节点都是一个对象，它通过一个引用指向对于的数据元素，同时还引用next 指向下一个节点
> 单链表(Singly linked list)
> 链表的第一个和最后一个节点，分别称作链表的首节点(Head) 和末节点(Tail)。末节点的特征是，其 next 引用为空
>
>

